---
title: "Quick Start"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{quickstart}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

## Overview

This vignette provides an overview of the tiledbsc R package which uses the open source [SOMA data model](https://github.com/single-cell-data/SOMA) to store single-cell data in a collection of TileDB arrays.

With tiledbsc you can:

- convert datas from Seurat and other popular single-cell formats into SOMA
- access SOMA data using any of TileDB's APIs
- store your datasets on S3 (or other remote object stores) and slice directly without having to download anything first

In this vignette you'll learn how to:

- ingest *Seurat* data into TileDB-backed SOMA Collections
- access various components of a dataset
- slice by cell-/feature-identifiers
- query using cell-/feature-level annotations
- update a SOMA with analysis results
- load data from SOMA into R as a *Seurat* or *Bioconductor* object

## Setup


```r
library(tiledbsc)
library(SeuratObject)
```

```
## Attaching sp
```

For this tutorial we'll use a dataset from 10X genomics containing 2,700 peripheral blood mononuclear cells (PBMC) from a healthy donor. The dataset is available on [10X Genomics' website](https://support.10xgenomics.com/single-cell-gene-expression/datasets/1.1.0/pbmc3k).

Use the provided helper function to download the filtered gene/cell matrix from 10X and create a `Seurat` object.


```r
pbmc3k <- dataset_seurat_pbmc3k()
```

```
## Error in dataset_seurat_pbmc3k(): could not find function "dataset_seurat_pbmc3k"
```

```r
pbmc3k
```

```
## Error in eval(expr, envir, enclos): object 'pbmc3k' not found
```

## Populate a SOMACollection

Our first step is to create a new `SOMACollection` at a specific URI. The URI could be a local filepath, an S3 URI, or as discussed below, a TileDB Cloud URI that automatically registers the dataset on TileDB Cloud.


```r
soco_uri <- file.path(tempdir(), "soco-pbmc3k")

soco <- SOMACollection$new(uri = soco_uri)
```

```
## No SOMACollection currently exists at '/var/folders/rn/r3r2rnt56z98l344kf1tq5ph0000gn/T//RtmpGPpkYq/soco-pbmc3k'
```

```
## Creating new SOMACollection at '/var/folders/rn/r3r2rnt56z98l344kf1tq5ph0000gn/T//RtmpGPpkYq/soco-pbmc3k'
```

```
## No TileDBGroup currently exists at '/var/folders/rn/r3r2rnt56z98l344kf1tq5ph0000gn/T//RtmpGPpkYq/soco-pbmc3k/uns'
```

```
## Creating new TileDBGroup at '/var/folders/rn/r3r2rnt56z98l344kf1tq5ph0000gn/T//RtmpGPpkYq/soco-pbmc3k/uns'
```

```r
soco
```

```
##   uri: /var/folders/rn/r3r2rnt56z98l344kf1tq5ph0000gn/T//RtmpGPpkYq/soco-pbmc3k 
## <SOMACollection>
##   groups: uns
```

Now we use tiledbsc to automatically ingest the various components of the `pbmc3k` object into the new `SOMACollection`.


```r
soco$from_seurat(pbmc3k)
```

```
## Error in inherits(object, "Seurat"): object 'pbmc3k' not found
```

Printing the `soco` object shows it comprises 2 members: `RNA`, which contains the RNA assay data, and `uns`, which is a special group for miscellaneous (i.e., unstructured) data.


```r
soco
```

```
##   uri: /var/folders/rn/r3r2rnt56z98l344kf1tq5ph0000gn/T//RtmpGPpkYq/soco-pbmc3k 
## <SOMACollection>
##   groups: uns
```

## Access SOMA Components

As this dataset is unimodal, we'll extract the SOMA containing the RNA data.


```r
soma <- soco$get_member("RNA")
soma
```

```
## NULL
```

Access the [`AnnotationDataframe`] representing the `obs` array containing cell-level metadata stored in `obs`.


```r
soma$obs
```

```
## NULL
```

Read it into memory as a `data.frame`.


```r
obs <- soma$obs$to_dataframe()
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

```r
summary(obs)
```

```
## Error in h(simpleError(msg, call)): error in evaluating the argument 'object' in selecting a method for function 'summary': object 'obs' not found
```

Access the [`AssayMatrix`] representing the `X` array containing the raw RNA
counts.


```r
soma$X$members$counts
```

```
## NULL
```

Read it into memory as a [`dgTMatrix`][`Matrix::TsparseMatrix-class`].


```r
mat <- soma$X$members$counts$to_matrix()
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

```r
dim(mat)
```

```
## Error in eval(expr, envir, enclos): object 'mat' not found
```

## Dimension Slicing and Attribute Filtering

`SOMACollection` and `SOMA` objects can be sliced by a combination of obs and var identifiers.


```r
soma$set_query(obs_ids = head(colnames(pbmc3k), 10))
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

This slice is automatically applied to the entire SOMA, so any component read into memory will now only contain the filtered results.


```r
soma$obs$to_dataframe()
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

To remove the filter simply reset the query.


```r
soma$reset_query()
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

```r
soma$obs$to_dataframe()
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

In addition to dimension slicing we can also apply filters using the cell- and feature-level metadata stored in the `obs` and `var` arrays.


```r
soma$set_query(
    obs_attr_filter = seurat_annotations == "B" && nCount_RNA > 1000
)
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

We can load the SOMA slice into memory as a Seurat `Assay`...


```r
soma$to_seurat_assay()
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

or as a Bioconductor [`SummarizedExperiment`].


```r
if (requireNamespace("SummarizedExperiment", quietly = TRUE)) {
  soma$to_summarized_experiment()
}
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

See `vignette("filtering", package = "tiledbsc")` for more details.

## Adding Analysis Results to a SOMA

The original `pbmc3k` object contains only the raw counts data. Here we'll use `Seurat` to generate new results and add them to the `soma`.

### Add Layer for Normalized Counts

First we normalize the raw counts, which creates a new matrix stored in the `Assay` object.


```r
pbmc3k <- Seurat::NormalizeData(pbmc3k, normalization.method = "LogNormalize")
```

```
## Error in Seurat::NormalizeData(pbmc3k, normalization.method = "LogNormalize"): object 'pbmc3k' not found
```

Currently the RNA SOMA's X group contains only a single layer, _counts_.


```r
soma$X
```

```
## NULL
```

Add a new `X` layer containing log-normalized counts stored in the Seurat `Assay`'s `data` slot.


```r
soma$from_seurat_assay(
  object = pbmc3k[["RNA"]],
  layers = "data",
  var = FALSE
)
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

Now we can see the SOMA contains 2 `X` layers: `counts` and `data`.


```r
soma$X
```

```
## NULL
```

### Add Layer for Scaled counts

First, we identify highly variable subset of genes to scale.


```r
var_genes <- VariableFeatures(
  Seurat::FindVariableFeatures(pbmc3k, nfeatures = 2000)
)
```

```
## Error in Seurat::FindVariableFeatures(pbmc3k, nfeatures = 2000): object 'pbmc3k' not found
```

Then generate the scaled data.


```r
pbmc3k <- Seurat::ScaleData(pbmc3k, features = var_genes)
```

```
## Error in Seurat::ScaleData(pbmc3k, features = var_genes): object 'pbmc3k' not found
```


And ingest the scaled data into a new `X` layer called `"scale.data"`.


```r
soma$from_seurat_assay(
    object = pbmc3k[["RNA"]],
    layers = "scale.data",
    var = FALSE
)
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

Again, verify the new layer was added.


```r
soma$X
```

```
## NULL
```

### Add Dimensional Reduction Results

We can use a similar workflow for dimensional reduction results, which are stored in either the `obsm` or `varm` slots of a SOMA.


```r
dimreduc_pca <- Reductions(
  Seurat::RunPCA(pbmc3k, features = var_genes),
  slot = "pca"
)
```

```
## Error in Seurat::RunPCA(pbmc3k, features = var_genes): object 'pbmc3k' not found
```

Add the Seurat `DimReduc` object to the SOMA.


```r
soma$add_seurat_dimreduction(
    dimreduc_pca,
    technique = "pca"
)
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

The SOMA now contains 2 new arrays, one within the `obsm` group storing the cell embeddings


```r
soma$obsm
```

```
## NULL
```

and a second within the `varm` group storing the feature loadings.


```r
soma$varm
```

```
## NULL
```

Either of these can be accessed and queried directly, which is often useful for visualization applications.


```r
obsm_pca <- soma$obsm$get_member("dimreduction_pca")
```

```
## Error in eval(expr, envir, enclos): attempt to apply non-function
```

```r
obsm_pca
```

```
## Error in eval(expr, envir, enclos): object 'obsm_pca' not found
```

Here we'll load the cell embeddings as a `matrix` and visualize the first 5 PCs.


```r
cell_pcs <- obsm_pca$to_matrix()
```

```
## Error in eval(expr, envir, enclos): object 'obsm_pca' not found
```

```r
pairs(cell_pcs[, 1:5])
```

```
## Error in pairs(cell_pcs[, 1:5]): object 'cell_pcs' not found
```

## Populate a SOMACollection in TileDB Cloud

You can ingest a Seurat object into an S3 `SOMACollection` that's automatically registered with TileDB Cloud using a special URI composed of:

-   your TileDB namespace
-   an S3 bucket where the dataset will be created

and running the same initialization/ingestion steps we performed earlier:

```r
soco <- SOMACollection$new("tiledb://<namespace>/s3://<bucket>/pbmc3k-soco")
soco$from_seurat(pbmc3k)
```

Note this assumes you:

-   have a TileDB Cloud account
-   registered [cloud
    credentials](https://cloud.tiledb.com/user-settings/credentials) for
    AWS
-   provided a [default S3 storage
    path](https://cloud.tiledb.com/user-settings/storage-paths)
-   are [logged into TileDB
    Cloud](https://tiledb-inc.github.io/TileDB-Cloud-R/articles/Login.html)
    in your environment

You can then view the new SOMACollection directly on TileDB Cloud where you can
inspect the various dataset components, share securely, view activity logs, and more. For example, here's the TileDB Cloud view of the `pbmc3k` dataset we just ingested: [`aaronwolen/pbmc3k-soco`](https://cloud.tiledb.com/groups/aaronwolen/68ffab71-b090-42c9-8d8b-977d00979257/overview).

You can also securely access the dataset directly via R (or Python) using its TileDB Cloud URI, `tiledb://aaronwolen/pbmc3k-soco`.
