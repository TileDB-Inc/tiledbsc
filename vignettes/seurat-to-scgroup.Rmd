---
title: "Seurat to sc_group"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Seurat to sc_group}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

## Setup

```{r setup}
options(max.print = 500)

library(tiledbsc)
library(fs)
library(tiledb)
library(Seurat)
library(SeuratData)

dataset_name <- "pbmc3k"
data_dir <- file.path(tempdir(), "vignette-data")
dir.create(data_dir, showWarnings = FALSE)
```

## Load data

```{r}
dataset_pkg <- paste0(dataset_name, ".SeuratData")
if (!requireNamespace(dataset_pkg, quietly = TRUE)) {
  message(paste("Installing", dataset_name))
  SeuratData::InstallData(dataset_name)
}
```

```{r}
pbmc.rna <- LoadData(dataset_name)
```

Feature-level annotations are empty for this dataset. To aid in testing we add an `ensembl_id` column containing Ensembl identifiers.

```{r}
suppressPackageStartupMessages(library(org.Hs.eg.db))

var_df <- GetAssay(pbmc.rna)[[]]

var_df$ensembl_id <- unname(
  mapIds(
    org.Hs.eg.db,
    keys = rownames(var_df),
    keytype = "SYMBOL",
    column = "ENSEMBL",
    multiVals = "first"
  )
)

pbmc.rna[["RNA"]] <- AddMetaData(pbmc.rna[["RNA"]], var_df)
```

We'll also normalize the data so the `Assay`'s `counts` and `data` slots contain different values.

```{r}
pbmc.rna <- NormalizeData(pbmc.rna, normalization.method = "LogNormalize")
```

# Step-by-step Conversion from Seurat to a TileDB `sc_group`

Create URIs for each of the 3 arrays that will make up the new `sc_group`:

```{r}
sc_group_uris <- sapply(c("X", "obs", "var"), \(x) file.path(data_dir, x))
sc_group_uris
```

## Assay data

Single-cell data stored in the `Assay` slot of the `Seurat` object is stored in the `X` array of an `sc_group`.

Create a new instance of `SCGroup_X` and specify its location.

```{r}
scgroup_x <- SCGroup_X$new(uri = sc_group_uris[["X"]])
```

Then we'll ingest the `counts` data from the `Assay`, which is returned from Seurat as a `dgCMatrix`, into the `X` array using the `SCGroup_X`'s `from_matrix()` method.

*Note: `SCGroup_X` class supports ingesting multiple transformations of the assay into the same array as a COO-formatted data frame. We are only ingesting a single transformation for demonstration purposes.*

```{r}
scgroup_x$from_matrix(
  x = GetAssayData(object = pbmc.rna, slot = "counts")
)
```

Examine the contents of the newly created `X` array.

```{r}
fs::dir_tree(scgroup_x$uri)
```

Data stored in the `X` array can then be loaded back into R in the same `dGTMatrix` format:

```{r}
scgroup_x$to_matrix(attr = "counts")
```

## Feature (variable) annotations

Both `var` and `obs` annotations are handled by the same `SCGroup_Annotation` class.

Create one instance of `SCGroup_Annotation` for the variable annotations:

```{r}
scgroup_var <- SCGroup_Annotation$new(uri = sc_group_uris[["var"]])
```

Ingest the `data.frame` containing the RNA assay's feature annotations into the `var` array.

```{r}
scgroup_var$from_dataframe(
  x = GetAssay(pbmc.rna, assay = "RNA")[[]]
)
```

Examine the contents of the newly created `var` array.

```{r}
fs::dir_tree(scgroup_var$uri)
```

Retrieve the feature annotations from the `var` array:

```{r}
# return only the first 10 rows
scgroup_var$to_dataframe()[1:10, , drop = FALSE]
```

## Observation (sample) annotations

Create a second instance of `SCGroup_Annotation` for the observation annotations:

```{r}
scgroup_obs <- SCGroup_Annotation$new(uri = sc_group_uris[["obs"]])
```

Ingest `data.frame` containing observation annotations into the `obs` component.

```{r}
scgroup_obs$from_dataframe(
  x = pbmc.rna[[]]
)
```

Retrieve the observation annotations from the `obs` array:

```{r}
# return only the first 10 rows
scgroup_obs$to_dataframe()[1:10, ]
```

# Array Access

## Helpers

The `SCGroup` classes include a number of helper functions for interacting with the underying arrays.

Print the schema of an array:

```{r}
scgroup_obs$schema()
```

List the names of the array's dimensions (i.e., indexed columns)

```{r}
scgroup_x$dimnames()
```

and attributes (i.e., non-indexed columns):

```{r}
scgroup_obs$attrnames()
```

## TileDB API access

You can also use the `tiledb_array()` method to directly access the underlying arrays using the standard TileDB API, providing the full functionality of the [`tiledb`][tiledb-r] package. For example, let's query the `obs` array and  retrieve a subset of cells that match our QC criteria:

```{r}
obs_array <- scgroup_obs$tiledb_array(
  return_as = "tibble",
  attrs = c("nCount_RNA", "nFeature_RNA", "seurat_annotations"),
  query_condition = parse_query_condition(nFeature_RNA < 2500)
)

obs_array[]
```


# Convert a Seurat `Assay` to TileDB-backed `sc_group`

Now we'll use the higher-level `SCGroup` class to handle the conversion from a Seurat `Assay` object to a TileDB `sc_group`.

First, create the empty TileDB group:

```{r}
scgroup_uri <- file.path(data_dir, "sc_group")
scgroup <- SCGroup$new(uri = scgroup_uri)

fs::dir_tree(scgroup_uri)
```

Then we'll pass `RNA` assay from `pmbc.rna` to the `from_seurat_assay()` method of the `SCGroup` class, which will create and populate the `X` and `var` with the corresponding data from the `Assay` object:

- the `counts`, `data`, and `scale.data` matrices are each stored in separate attribute of the `X` array
- the `data.frame` containing feature-level metadata is ingested into the `var` array

Because cell-level metadata is stored in the parent `Seurat` object, we need to provide this data separately.

```{r}
scgroup$from_seurat_assay(
  object = GetAssay(pbmc.rna, assay = "RNA"),
  obs = pbmc.rna[[]]
)
```

Examine the directory structure of the `sc_group` we can see the `X`, `var`, and `obs` arrays have all been created.

```{r}
fs::dir_tree(scgroup_uri)
```

Any of the underlying TileDB arrays can be accessed directly from the `sc_group` object. For example, let's access the `obs` array and return the cell-level metadata using `to_dataframe()`:

```{r}
head(scgroup$obs$to_dataframe())
```


From the TileDB `sc_group` we can load the data back into memory as a _Seurat_ `Assay` object:

```{r}
scgroup$to_seurat_assay()
```

# Convert a `Seurat` object to a TileDB-backed `sc_dataset`

Finally, we'll use the top-level `SCDataset` class to convert an entire `Seurat` object to an `sc_dataset`. This is the recommended way to perform a conversion since it can handle multiple `Assay` objects and will eventually convert all the standard slots that comprise a `Seurat` object.

As before with the `SCGroup` above, we first need to create a new `SCDataset` object:

```{r}
scdataset_uri <- file.path(data_dir, "sc_dataset")
scdataset <- SCDataset$new(uri = scdataset_uri)
```

Then we can then pass the entire `pbmc.rna` object directly to `from_seurat()` and one `sc_group` will be created for each `Assay` object:

```{r}
scdataset$from_seurat(object = pbmc.rna)
```

You can see the group contains one `scgroup_RNA` directory, as well as all of its various components:

```{r}
fs::dir_tree(scdataset$uri)
```

To close the loop we can then read the on-disk `sc_dataset` back into memory as a `Seurat` object.

```{r}
scdataset$to_seurat(project = "SCDataset Example")
```

# Session

```{r}
sessionInfo()
```

```{r cleanup, include=FALSE}
tiledb::tiledb_vfs_remove_dir(data_dir)
```

<!-- links -->
[tiledb-r]: https://tiledb-inc.github.io/TileDB-R/
